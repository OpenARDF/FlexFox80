
LEDBlinkusingTimerInterrupt.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00804000  000003ec  00000480  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000003ec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00804010  00804010  00000490  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000490  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000004c0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000218  00000000  00000000  00000500  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005409  00000000  00000000  00000718  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003559  00000000  00000000  00005b21  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000126a  00000000  00000000  0000907a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000330  00000000  00000000  0000a2e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001fd6  00000000  00000000  0000a614  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000003b2  00000000  00000000  0000c5ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000148  00000000  00000000  0000c99c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__ctors_end>
   4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 98 00 	jmp	0x130	; 0x130 <__vector_7>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 a7 00 	jmp	0x14e	; 0x14e <__vector_12>
  34:	0c 94 ba 00 	jmp	0x174	; 0x174 <__vector_13>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  78:	0c 94 cd 00 	jmp	0x19a	; 0x19a <__vector_30>
  7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a4:	0c 94 e0 00 	jmp	0x1c0	; 0x1c0 <__vector_41>
  a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  e4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e8 <__ctors_end>:
  e8:	11 24       	eor	r1, r1
  ea:	1f be       	out	0x3f, r1	; 63
  ec:	cf ef       	ldi	r28, 0xFF	; 255
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	df e7       	ldi	r29, 0x7F	; 127
  f2:	de bf       	out	0x3e, r29	; 62

000000f4 <__do_copy_data>:
  f4:	10 e4       	ldi	r17, 0x40	; 64
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b0 e4       	ldi	r27, 0x40	; 64
  fa:	ec ee       	ldi	r30, 0xEC	; 236
  fc:	f3 e0       	ldi	r31, 0x03	; 3
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a0 31       	cpi	r26, 0x10	; 16
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	20 e4       	ldi	r18, 0x40	; 64
 110:	a0 e1       	ldi	r26, 0x10	; 16
 112:	b0 e4       	ldi	r27, 0x40	; 64
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	a2 31       	cpi	r26, 0x12	; 18
 11a:	b2 07       	cpc	r27, r18
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	0e 94 33 01 	call	0x266	; 0x266 <main>
 122:	0c 94 f4 01 	jmp	0x3e8	; 0x3e8 <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
 12a:	0e 94 ac 01 	call	0x358	; 0x358 <system_init>
 12e:	08 95       	ret

00000130 <__vector_7>:

#include <driver_init.h>
#include <compiler.h>

ISR(TCA0_OVF_vect)
{
 130:	1f 92       	push	r1
 132:	0f 92       	push	r0
 134:	0f b6       	in	r0, 0x3f	; 63
 136:	0f 92       	push	r0
 138:	11 24       	eor	r1, r1
 13a:	8f 93       	push	r24
	/* Insert your TCA overflow interrupt handling code */
//	LED_toggle_level();

	/* The interrupt flag has to be cleared manually */
	TCA0.SINGLE.INTFLAGS = TCA_SINGLE_OVF_bm;
 13c:	81 e0       	ldi	r24, 0x01	; 1
 13e:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <__TEXT_REGION_LENGTH__+0x7e0a0b>
}
 142:	8f 91       	pop	r24
 144:	0f 90       	pop	r0
 146:	0f be       	out	0x3f, r0	; 63
 148:	0f 90       	pop	r0
 14a:	1f 90       	pop	r1
 14c:	18 95       	reti

0000014e <__vector_12>:

/**
Periodic tasks not requiring precise timing. Rate = 300 Hz
*/
ISR(TCB0_INT_vect)
{
 14e:	1f 92       	push	r1
 150:	0f 92       	push	r0
 152:	0f b6       	in	r0, 0x3f	; 63
 154:	0f 92       	push	r0
 156:	11 24       	eor	r1, r1
 158:	8f 93       	push	r24
    /**
     * The interrupt flag is cleared by writing 1 to it, or when the Capture register
     * is read in Capture mode
     */

    if(TCB0.INTFLAGS & TCB_CAPT_bm)
 15a:	80 91 06 0b 	lds	r24, 0x0B06	; 0x800b06 <__TEXT_REGION_LENGTH__+0x7e0b06>
 15e:	80 ff       	sbrs	r24, 0
 160:	03 c0       	rjmp	.+6      	; 0x168 <__vector_12+0x1a>
    {
        TCB0.INTFLAGS = TCB_CAPT_bm;
 162:	81 e0       	ldi	r24, 0x01	; 1
 164:	80 93 06 0b 	sts	0x0B06, r24	; 0x800b06 <__TEXT_REGION_LENGTH__+0x7e0b06>
    }
}
 168:	8f 91       	pop	r24
 16a:	0f 90       	pop	r0
 16c:	0f be       	out	0x3f, r0	; 63
 16e:	0f 90       	pop	r0
 170:	1f 90       	pop	r1
 172:	18 95       	reti

00000174 <__vector_13>:

ISR(TCB1_INT_vect)
{
 174:	1f 92       	push	r1
 176:	0f 92       	push	r0
 178:	0f b6       	in	r0, 0x3f	; 63
 17a:	0f 92       	push	r0
 17c:	11 24       	eor	r1, r1
 17e:	8f 93       	push	r24
    if(TCB1.INTFLAGS & TCB_CAPT_bm)
 180:	80 91 16 0b 	lds	r24, 0x0B16	; 0x800b16 <__TEXT_REGION_LENGTH__+0x7e0b16>
 184:	80 ff       	sbrs	r24, 0
 186:	03 c0       	rjmp	.+6      	; 0x18e <__vector_13+0x1a>
    {
        TCB1.INTFLAGS = TCB_CAPT_bm;
 188:	81 e0       	ldi	r24, 0x01	; 1
 18a:	80 93 16 0b 	sts	0x0B16, r24	; 0x800b16 <__TEXT_REGION_LENGTH__+0x7e0b16>
    }
}
 18e:	8f 91       	pop	r24
 190:	0f 90       	pop	r0
 192:	0f be       	out	0x3f, r0	; 63
 194:	0f 90       	pop	r0
 196:	1f 90       	pop	r1
 198:	18 95       	reti

0000019a <__vector_30>:

ISR(TCB2_INT_vect)
{
 19a:	1f 92       	push	r1
 19c:	0f 92       	push	r0
 19e:	0f b6       	in	r0, 0x3f	; 63
 1a0:	0f 92       	push	r0
 1a2:	11 24       	eor	r1, r1
 1a4:	8f 93       	push	r24
	if(TCB2.INTFLAGS & TCB_CAPT_bm)
 1a6:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
 1aa:	80 ff       	sbrs	r24, 0
 1ac:	03 c0       	rjmp	.+6      	; 0x1b4 <__vector_30+0x1a>
    {
        TCB2.INTFLAGS = TCB_CAPT_bm;
 1ae:	81 e0       	ldi	r24, 0x01	; 1
 1b0:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
    }
}
 1b4:	8f 91       	pop	r24
 1b6:	0f 90       	pop	r0
 1b8:	0f be       	out	0x3f, r0	; 63
 1ba:	0f 90       	pop	r0
 1bc:	1f 90       	pop	r1
 1be:	18 95       	reti

000001c0 <__vector_41>:

/**
One second counter based on CPU clock.
*/
ISR(TCB3_INT_vect)
{
 1c0:	1f 92       	push	r1
 1c2:	0f 92       	push	r0
 1c4:	0f b6       	in	r0, 0x3f	; 63
 1c6:	0f 92       	push	r0
 1c8:	11 24       	eor	r1, r1
 1ca:	2f 93       	push	r18
 1cc:	3f 93       	push	r19
 1ce:	8f 93       	push	r24
 1d0:	9f 93       	push	r25
    /**
     * The interrupt flag is cleared by writing 1 to it, or when the Capture register
     * is read in Capture mode
     */

    if(TCB3.INTFLAGS & TCB_CAPT_bm)
 1d2:	80 91 36 0b 	lds	r24, 0x0B36	; 0x800b36 <__TEXT_REGION_LENGTH__+0x7e0b36>
 1d6:	80 ff       	sbrs	r24, 0
 1d8:	18 c0       	rjmp	.+48     	; 0x20a <__EEPROM_REGION_LENGTH__+0xa>
    {
		if(cnt++ == 299)
 1da:	80 91 10 40 	lds	r24, 0x4010	; 0x804010 <__data_end>
 1de:	90 91 11 40 	lds	r25, 0x4011	; 0x804011 <__data_end+0x1>
 1e2:	9c 01       	movw	r18, r24
 1e4:	2f 5f       	subi	r18, 0xFF	; 255
 1e6:	3f 4f       	sbci	r19, 0xFF	; 255
 1e8:	20 93 10 40 	sts	0x4010, r18	; 0x804010 <__data_end>
 1ec:	30 93 11 40 	sts	0x4011, r19	; 0x804011 <__data_end+0x1>
 1f0:	8b 32       	cpi	r24, 0x2B	; 43
 1f2:	91 40       	sbci	r25, 0x01	; 1
 1f4:	39 f4       	brne	.+14     	; 0x204 <__EEPROM_REGION_LENGTH__+0x4>
		{
			cnt = 0;
 1f6:	10 92 10 40 	sts	0x4010, r1	; 0x804010 <__data_end>
 1fa:	10 92 11 40 	sts	0x4011, r1	; 0x804011 <__data_end+0x1>
 *
 * \param[in] pin       The pin number within port
 */
static inline void PORTC_toggle_pin_level(const uint8_t pin)
{
	VPORTC.IN |= 1 << pin;
 1fe:	8a b1       	in	r24, 0x0a	; 10
 200:	80 64       	ori	r24, 0x40	; 64
 202:	8a b9       	out	0x0a, r24	; 10
			LED_toggle_level();
		}

        TCB3.INTFLAGS = TCB_CAPT_bm;
 204:	81 e0       	ldi	r24, 0x01	; 1
 206:	80 93 36 0b 	sts	0x0B36, r24	; 0x800b36 <__TEXT_REGION_LENGTH__+0x7e0b36>
    }
}
 20a:	9f 91       	pop	r25
 20c:	8f 91       	pop	r24
 20e:	3f 91       	pop	r19
 210:	2f 91       	pop	r18
 212:	0f 90       	pop	r0
 214:	0f be       	out	0x3f, r0	; 63
 216:	0f 90       	pop	r0
 218:	1f 90       	pop	r1
 21a:	18 95       	reti

0000021c <USART1_sendChar>:



void USART1_sendChar(char c)
{
	while (!(USART1.STATUS & USART_DREIF_bm)) {
 21c:	90 91 24 08 	lds	r25, 0x0824	; 0x800824 <__TEXT_REGION_LENGTH__+0x7e0824>
 220:	95 ff       	sbrs	r25, 5
 222:	fc cf       	rjmp	.-8      	; 0x21c <USART1_sendChar>
		;
	}

	USART1.TXDATAL = c;
 224:	80 93 22 08 	sts	0x0822, r24	; 0x800822 <__TEXT_REGION_LENGTH__+0x7e0822>
 228:	08 95       	ret

0000022a <USART1_sendString>:
}

void USART1_sendString(char *str)
{
 22a:	0f 93       	push	r16
 22c:	1f 93       	push	r17
 22e:	cf 93       	push	r28
 230:	df 93       	push	r29
 232:	8c 01       	movw	r16, r24
	for (size_t i = 0; i < strlen(str); i++) {
 234:	c0 e0       	ldi	r28, 0x00	; 0
 236:	d0 e0       	ldi	r29, 0x00	; 0
 238:	07 c0       	rjmp	.+14     	; 0x248 <USART1_sendString+0x1e>
		USART1_sendChar(str[i]);
 23a:	f8 01       	movw	r30, r16
 23c:	ec 0f       	add	r30, r28
 23e:	fd 1f       	adc	r31, r29
 240:	80 81       	ld	r24, Z
 242:	0e 94 0e 01 	call	0x21c	; 0x21c <USART1_sendChar>
	USART1.TXDATAL = c;
}

void USART1_sendString(char *str)
{
	for (size_t i = 0; i < strlen(str); i++) {
 246:	21 96       	adiw	r28, 0x01	; 1
 248:	f8 01       	movw	r30, r16
 24a:	01 90       	ld	r0, Z+
 24c:	00 20       	and	r0, r0
 24e:	e9 f7       	brne	.-6      	; 0x24a <USART1_sendString+0x20>
 250:	31 97       	sbiw	r30, 0x01	; 1
 252:	e0 1b       	sub	r30, r16
 254:	f1 0b       	sbc	r31, r17
 256:	ce 17       	cp	r28, r30
 258:	df 07       	cpc	r29, r31
 25a:	78 f3       	brcs	.-34     	; 0x23a <USART1_sendString+0x10>
		USART1_sendChar(str[i]);
	}
}
 25c:	df 91       	pop	r29
 25e:	cf 91       	pop	r28
 260:	1f 91       	pop	r17
 262:	0f 91       	pop	r16
 264:	08 95       	ret

00000266 <main>:

int main(void)
{
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
 266:	0e 94 95 00 	call	0x12a	; 0x12a <atmel_start_init>

	/* Replace with your application code */
	while (1) {
		USART1_sendString("Hello World!\r\n");
 26a:	80 e0       	ldi	r24, 0x00	; 0
 26c:	90 e4       	ldi	r25, 0x40	; 64
 26e:	0e 94 15 01 	call	0x22a	; 0x22a <USART1_sendString>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 272:	2f ef       	ldi	r18, 0xFF	; 255
 274:	84 e3       	ldi	r24, 0x34	; 52
 276:	9c e0       	ldi	r25, 0x0C	; 12
 278:	21 50       	subi	r18, 0x01	; 1
 27a:	80 40       	sbci	r24, 0x00	; 0
 27c:	90 40       	sbci	r25, 0x00	; 0
 27e:	e1 f7       	brne	.-8      	; 0x278 <main+0x12>
 280:	00 c0       	rjmp	.+0      	; 0x282 <main+0x1c>
 282:	00 00       	nop
 284:	f2 cf       	rjmp	.-28     	; 0x26a <main+0x4>

00000286 <BOD_init>:
int8_t BOD_init()
{

	// ccp_write_io((void*)&(BOD.CTRLA),BOD_SLEEP_DIS_gc /* Disabled */);

	BOD.INTCTRL = 0 << BOD_VLMIE_bp        /* voltage level monitor interrrupt enable: disabled */
 286:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
	              | BOD_VLMCFG_FALLING_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
 28a:	80 e0       	ldi	r24, 0x00	; 0
 28c:	08 95       	ret

0000028e <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
 28e:	44 e2       	ldi	r20, 0x24	; 36
 290:	68 ed       	ldi	r22, 0xD8	; 216
 292:	88 e6       	ldi	r24, 0x68	; 104
 294:	90 e0       	ldi	r25, 0x00	; 0
 296:	0e 94 c3 01 	call	0x386	; 0x386 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
 29a:	80 e0       	ldi	r24, 0x00	; 0
 29c:	08 95       	ret

0000029e <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
 29e:	78 94       	sei

	return 0;
}
 2a0:	80 e0       	ldi	r24, 0x00	; 0
 2a2:	08 95       	ret

000002a4 <mcu_init>:
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
 2a4:	80 e0       	ldi	r24, 0x00	; 0
 2a6:	08 c0       	rjmp	.+16     	; 0x2b8 <mcu_init+0x14>
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
 2a8:	e8 2f       	mov	r30, r24
 2aa:	f0 e0       	ldi	r31, 0x00	; 0
 2ac:	e0 5f       	subi	r30, 0xF0	; 240
 2ae:	fb 4f       	sbci	r31, 0xFB	; 251
 2b0:	90 81       	ld	r25, Z
 2b2:	98 60       	ori	r25, 0x08	; 8
 2b4:	90 83       	st	Z, r25
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
 2b6:	8f 5f       	subi	r24, 0xFF	; 255
 2b8:	88 30       	cpi	r24, 0x08	; 8
 2ba:	b0 f3       	brcs	.-20     	; 0x2a8 <mcu_init+0x4>
 2bc:	80 e0       	ldi	r24, 0x00	; 0
 2be:	08 c0       	rjmp	.+16     	; 0x2d0 <mcu_init+0x2c>
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
 2c0:	e8 2f       	mov	r30, r24
 2c2:	f0 e0       	ldi	r31, 0x00	; 0
 2c4:	e0 5d       	subi	r30, 0xD0	; 208
 2c6:	fb 4f       	sbci	r31, 0xFB	; 251
 2c8:	90 81       	ld	r25, Z
 2ca:	98 60       	ori	r25, 0x08	; 8
 2cc:	90 83       	st	Z, r25

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
 2ce:	8f 5f       	subi	r24, 0xFF	; 255
 2d0:	88 30       	cpi	r24, 0x08	; 8
 2d2:	b0 f3       	brcs	.-20     	; 0x2c0 <mcu_init+0x1c>
 2d4:	80 e0       	ldi	r24, 0x00	; 0
 2d6:	08 c0       	rjmp	.+16     	; 0x2e8 <mcu_init+0x44>
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
 2d8:	e8 2f       	mov	r30, r24
 2da:	f0 e0       	ldi	r31, 0x00	; 0
 2dc:	e0 5b       	subi	r30, 0xB0	; 176
 2de:	fb 4f       	sbci	r31, 0xFB	; 251
 2e0:	90 81       	ld	r25, Z
 2e2:	98 60       	ori	r25, 0x08	; 8
 2e4:	90 83       	st	Z, r25

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
 2e6:	8f 5f       	subi	r24, 0xFF	; 255
 2e8:	88 30       	cpi	r24, 0x08	; 8
 2ea:	b0 f3       	brcs	.-20     	; 0x2d8 <mcu_init+0x34>
 2ec:	80 e0       	ldi	r24, 0x00	; 0
 2ee:	08 c0       	rjmp	.+16     	; 0x300 <mcu_init+0x5c>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTD + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
 2f0:	e8 2f       	mov	r30, r24
 2f2:	f0 e0       	ldi	r31, 0x00	; 0
 2f4:	e0 59       	subi	r30, 0x90	; 144
 2f6:	fb 4f       	sbci	r31, 0xFB	; 251
 2f8:	90 81       	ld	r25, Z
 2fa:	98 60       	ori	r25, 0x08	; 8
 2fc:	90 83       	st	Z, r25

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
 2fe:	8f 5f       	subi	r24, 0xFF	; 255
 300:	88 30       	cpi	r24, 0x08	; 8
 302:	b0 f3       	brcs	.-20     	; 0x2f0 <mcu_init+0x4c>
 304:	80 e0       	ldi	r24, 0x00	; 0
 306:	08 c0       	rjmp	.+16     	; 0x318 <mcu_init+0x74>
		*((uint8_t *)&PORTD + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTE + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
 308:	e8 2f       	mov	r30, r24
 30a:	f0 e0       	ldi	r31, 0x00	; 0
 30c:	e0 57       	subi	r30, 0x70	; 112
 30e:	fb 4f       	sbci	r31, 0xFB	; 251
 310:	90 81       	ld	r25, Z
 312:	98 60       	ori	r25, 0x08	; 8
 314:	90 83       	st	Z, r25

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTD + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
 316:	8f 5f       	subi	r24, 0xFF	; 255
 318:	88 30       	cpi	r24, 0x08	; 8
 31a:	b0 f3       	brcs	.-20     	; 0x308 <mcu_init+0x64>
 31c:	80 e0       	ldi	r24, 0x00	; 0
 31e:	08 c0       	rjmp	.+16     	; 0x330 <mcu_init+0x8c>
		*((uint8_t *)&PORTE + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTF + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
 320:	e8 2f       	mov	r30, r24
 322:	f0 e0       	ldi	r31, 0x00	; 0
 324:	e0 55       	subi	r30, 0x50	; 80
 326:	fb 4f       	sbci	r31, 0xFB	; 251
 328:	90 81       	ld	r25, Z
 32a:	98 60       	ori	r25, 0x08	; 8
 32c:	90 83       	st	Z, r25

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTE + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
 32e:	8f 5f       	subi	r24, 0xFF	; 255
 330:	88 30       	cpi	r24, 0x08	; 8
 332:	b0 f3       	brcs	.-20     	; 0x320 <mcu_init+0x7c>
		*((uint8_t *)&PORTF + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
 334:	08 95       	ret

00000336 <USART_0_initialization>:
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
 336:	88 b1       	in	r24, 0x08	; 8
 338:	8d 7f       	andi	r24, 0xFD	; 253
 33a:	88 b9       	out	0x08, r24	; 8
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
 33c:	e1 e5       	ldi	r30, 0x51	; 81
 33e:	f4 e0       	ldi	r31, 0x04	; 4
 340:	80 81       	ld	r24, Z
 342:	87 7f       	andi	r24, 0xF7	; 247
 344:	80 83       	st	Z, r24
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
 346:	89 b1       	in	r24, 0x09	; 9
 348:	8e 7f       	andi	r24, 0xFE	; 254
 34a:	89 b9       	out	0x09, r24	; 9
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
 34c:	88 b1       	in	r24, 0x08	; 8
 34e:	81 60       	ori	r24, 0x01	; 1
 350:	88 b9       	out	0x08, r24	; 8
	// <true"> High
	false);

	PC0_set_dir(PORT_DIR_OUT);

	USART_0_init();
 352:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <USART_0_init>
 356:	08 95       	ret

00000358 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
 358:	0e 94 52 01 	call	0x2a4	; 0x2a4 <mcu_init>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
 35c:	89 b1       	in	r24, 0x09	; 9
 35e:	8f 7b       	andi	r24, 0xBF	; 191
 360:	89 b9       	out	0x09, r24	; 9
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
 362:	88 b1       	in	r24, 0x08	; 8
 364:	80 64       	ori	r24, 0x40	; 64
 366:	88 b9       	out	0x08, r24	; 8
	    // <true"> High
	    false);

	LED_set_dir(PORT_DIR_OUT);

	CLKCTRL_init();
 368:	0e 94 47 01 	call	0x28e	; 0x28e <CLKCTRL_init>

	SLPCTRL_init();
 36c:	0e 94 c8 01 	call	0x390	; 0x390 <SLPCTRL_init>

	CPUINT_init();
 370:	0e 94 4f 01 	call	0x29e	; 0x29e <CPUINT_init>

	TIMER_0_init();
 374:	0e 94 ca 01 	call	0x394	; 0x394 <TIMER_0_init>
	TIMER_1_init();
 378:	0e 94 d6 01 	call	0x3ac	; 0x3ac <TIMER_1_init>
	USART_0_initialization();
 37c:	0e 94 9b 01 	call	0x336	; 0x336 <USART_0_initialization>
	

	BOD_init();
 380:	0e 94 43 01 	call	0x286	; 0x286 <BOD_init>
 384:	08 95       	ret

00000386 <protected_write_io>:
	PUBLIC_FUNCTION(protected_write_io)

#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
 386:	1b be       	out	0x3b, r1	; 59
#endif
	movw    r30, r24                // Load addr into Z
 388:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
 38a:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
 38c:	40 83       	st	Z, r20
	ret                             // Return to caller
 38e:	08 95       	ret

00000390 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
 390:	80 e0       	ldi	r24, 0x00	; 0
 392:	08 95       	ret

00000394 <TIMER_0_init>:
	//		 | 0 << TCA_SINGLE_CNTBEI_bp /* Count on Event Input B: disabled */
	//		 | TCA_SINGLE_EVACTA_CNT_POSEDGE_gc /* Count on positive edge event */
	//		 | TCA_SINGLE_EVACTB_UPDOWN_gc; /* Count on prescaled clock. Event controls count direction. Up-count when
	//event line is 0, down-count when event line is 1. */

	TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp   /* Compare 0 Interrupt: disabled */
 394:	e0 e0       	ldi	r30, 0x00	; 0
 396:	fa e0       	ldi	r31, 0x0A	; 10
 398:	81 e0       	ldi	r24, 0x01	; 1
 39a:	82 87       	std	Z+10, r24	; 0x0a
	                      | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	                      | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	                      | 1 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: enabled */

	TCA0.SINGLE.PER = 0xfff85; /* Period: 0x1e85 */
 39c:	85 e8       	ldi	r24, 0x85	; 133
 39e:	9f ef       	ldi	r25, 0xFF	; 255
 3a0:	86 a3       	std	Z+38, r24	; 0x26
 3a2:	97 a3       	std	Z+39, r25	; 0x27

	TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1024_gc    /* System Clock / 256 */
 3a4:	8f e0       	ldi	r24, 0x0F	; 15
 3a6:	80 83       	st	Z, r24
	                    | 1 << TCA_SINGLE_ENABLE_bp    /* Module Enable: enabled */
	                    | 0 << TCA_SINGLE_RUNSTDBY_bp; /* RUN STANDBY: disabled */

	return 0;
 3a8:	80 e0       	ldi	r24, 0x00	; 0
 3aa:	08 95       	ret

000003ac <TIMER_1_init>:
 *
 * \return Initialization status.
 */
int8_t TIMER_1_init()
{
TCB0.INTCTRL = 1 << TCB_CAPT_bp   /* Capture or Timeout: enabled */
 3ac:	e0 e0       	ldi	r30, 0x00	; 0
 3ae:	fb e0       	ldi	r31, 0x0B	; 11
 3b0:	81 e0       	ldi	r24, 0x01	; 1
 3b2:	85 83       	std	Z+5, r24	; 0x05
| 0 << TCB_OVF_bp; /* OverFlow Interrupt: disabled */

// Set TOP
TCB0.CCMP = 0x9C40;
 3b4:	20 e4       	ldi	r18, 0x40	; 64
 3b6:	3c e9       	ldi	r19, 0x9C	; 156
 3b8:	24 87       	std	Z+12, r18	; 0x0c
 3ba:	35 87       	std	Z+13, r19	; 0x0d

TCB0.CTRLA = TCB_CLKSEL_DIV2_gc     /* CLK_PER */
 3bc:	93 e0       	ldi	r25, 0x03	; 3
 3be:	90 83       	st	Z, r25
| 1 << TCB_ENABLE_bp   /* Enable: enabled */
| 0 << TCB_RUNSTDBY_bp /* Run Standby: disabled */
| 0 << TCB_SYNCUPD_bp  /* Synchronize Update: disabled */
| 0 << TCB_CASCADE_bp; /* Cascade Two Timer/Counters: disabled */

TCB0.INTFLAGS = TCB_CAPT_bm; /* Clear flag */
 3c0:	86 83       	std	Z+6, r24	; 0x06

/********************************************************************************/

TCB3.INTCTRL = 1 << TCB_CAPT_bp   /* Capture or Timeout: enabled */
 3c2:	e0 e3       	ldi	r30, 0x30	; 48
 3c4:	fb e0       	ldi	r31, 0x0B	; 11
 3c6:	85 83       	std	Z+5, r24	; 0x05
| 0 << TCB_OVF_bp; /* OverFlow Interrupt: disabled */

// Set TOP
TCB3.CCMP = 0x9C40;
 3c8:	24 87       	std	Z+12, r18	; 0x0c
 3ca:	35 87       	std	Z+13, r19	; 0x0d

TCB3.CTRLA = TCB_CLKSEL_DIV2_gc     /* CLK_PER */
 3cc:	90 83       	st	Z, r25
| 1 << TCB_ENABLE_bp   /* Enable: enabled */
| 0 << TCB_RUNSTDBY_bp /* Run Standby: disabled */
| 0 << TCB_SYNCUPD_bp  /* Synchronize Update: disabled */
| 0 << TCB_CASCADE_bp; /* Cascade Two Timer/Counters: disabled */

TCB3.INTFLAGS = TCB_CAPT_bm; /* Clear flag */
 3ce:	86 83       	std	Z+6, r24	; 0x06

	return 0;
 3d0:	80 e0       	ldi	r24, 0x00	; 0
 3d2:	08 95       	ret

000003d4 <USART_0_init>:
 * \retval 1 the USART init was not successful
 */
int8_t USART_0_init()
{

	USART1.BAUD = (uint16_t)USART1_BAUD_RATE(9600); /* set baud rate register */
 3d4:	e0 e2       	ldi	r30, 0x20	; 32
 3d6:	f8 e0       	ldi	r31, 0x08	; 8
 3d8:	80 e1       	ldi	r24, 0x10	; 16
 3da:	97 e2       	ldi	r25, 0x27	; 39
 3dc:	80 87       	std	Z+8, r24	; 0x08
 3de:	91 87       	std	Z+9, r25	; 0x09
	//		 | USART_RS485_DISABLE_gc /* RS485 Mode disabled */
	//		 | 0 << USART_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << USART_RXSIE_bp /* Receiver Start Frame Interrupt Enable: disabled */
	//		 | 0 << USART_TXCIE_bp; /* Transmit Complete Interrupt Enable: disabled */

	USART1.CTRLB = 0 << USART_MPCM_bp       /* Multi-processor Communication Mode: disabled */
 3e0:	80 e4       	ldi	r24, 0x40	; 64
 3e2:	86 83       	std	Z+6, r24	; 0x06
	// USART1.RXPLCTRL = 0x0 << USART_RXPL_gp; /* Receiver Pulse Length: 0x0 */

	// USART1.TXPLCTRL = 0x0 << USART_TXPL_gp; /* Transmit pulse length: 0x0 */

	return 0;
}
 3e4:	80 e0       	ldi	r24, 0x00	; 0
 3e6:	08 95       	ret

000003e8 <_exit>:
 3e8:	f8 94       	cli

000003ea <__stop_program>:
 3ea:	ff cf       	rjmp	.-2      	; 0x3ea <__stop_program>
